---
layout: post
title: 'K-D Tree'
author: pplat
date: 2020-02-09 03:00
tags: [k-d_tree]

---

k-d트리는 다차원의 점들(자료들)을 저장하기 위한 자료구조입니다. 알아보기 전에 먼저 저보다 훨씬 잘 설명해둔 위키피디아 페이지를 소개하겠습니다. ([링크](https://en.wikipedia.org/wiki/K-d_tree))

그냥 여기만으로 이해하는 게 훨씬 편할 수도 있습니다.

### 개요

설명하자면 k-d 트리는 모든 노드가 k차원 점인 이진 트리입니다. 모든 리프 노드는 공간을 반평면의 두 부분으로 나누는 분할 초평면을 만드는 것으로 생각할 수 있습니다. 이 초평면의 왼쪽은 그 노드의 왼쪽 부분 트리를 나타내고 오른쪽은 오른쪽 부분 트리를 나타냅니다. 초평면은 k차원 중 하나의 차원축에 수직적이어야 합니다. 그러니 예를 들어 x=3을 기준으로 x<3인 점을 왼쪽 서브트리에, x>3인 점을 오른쪽 서브트리에 둘 수 있겠죠.

### 작동 방식

그럼 이제부터 k-d 트리에서 어떻게 점을 저장하는지 자세히 알아보도록 합시다.

k차원의 점들이 N개 존재한다 합시다. 먼저 우리는 N개의 점들을 X좌표를 기준으로 나누어주어야 합니다. 적절하게 나누기 위해서는 그 점들의 x좌표의 중앙값을 기준으로 나누는 게 제일 적절하겠죠. 중앙값은 그냥 점들 전체를 정렬하면 O(NlogN)에 구할 수 있습니다. 더 빠르게도 구할 수 있다고 하는데, 그건 좀 논점 밖이죠.

그리고 그 노드에는 그 x좌표의 중앙값에 해당하는 점을 배치하고 그 점보다 x좌표가 작은 점들은 왼쪽, 그 점보다 x좌표가 큰 점들은 오른쪽으로 갑니다.

그리고 이제 다시 점들을 나눠줘야 되는데, 또 x좌표로 정렬하는 걸까요? 아닙니다. 그러면 x좌표가 모두 같을 때는 트리가 너무 비효율적인 구조로 만들어집니다. 대신 우리는 y좌표를 기준으로 하여 점들을 정렬해줍니다.

왼쪽에서도 y좌표를 기준으로 정렬해서 중앙값 기준으로 나눠주고, 오른쪽에서도 y좌표 기준으로 정렬해서 중앙값 기준으로 나눠줍니다.

그리고 또 점들은 더 밑으로 내려오겠죠. 그럼 그 점들은 이제 z좌표를 기준으로 나눠주면 됩니다! 물론 3차원 이상의 점이 아니라면 다시 x좌표 기준으로 나눠줍니다.

정리하자면, 점들의 차원이 k차원이고 현재 depth가 x일 때, (x%k) 번째 차원을 기준으로 점들을 나눠줍니다. (깊이와 차원은 모두 0-based)

### 예시

2차원에서 k-d tree를 나타낸 그림을 보여드리겠습니다.


![](https://i.imgur.com/inLhFDF.png)



2차원에서의 k-d tree
저 그림에서 어떻게 k-d tree가 구축되는지 알아봅시다. 먼저 모든 점들을 봅시다. (2,3),(4,7),(5,4),(8,1),(9,6),(7,2)가 있습니다. x좌표 순으로 정렬하면 (2,3),(4,7),(5,4),(7,2),(8,1),(9,6)입니다. 자료가 짝수 개인데 중앙값은 평균으로 뽑아야 될까요? 아니요. 그냥 3번째나 4번째 중에 맘에 드는 거 뽑습니다. 저는 4번째인 (7,2)를 뽑겠습니다.

그리고 깊이를 한 단계 내려갑시다. 왼쪽으로는 점 (2,3),(4,7),(5,4)이 내려옵니다. y좌표 기준으로 정렬했을 때 중간은 (5,4)이고 y좌표가 작은 (2,3)이 왼쪽, y좌표가 큰 (4,7)이 오른쪽으로 갑니다.

오른쪽에는 (8,1),(9,6)이 오는데 점이 두 개밖에 없으니 아무 거나 하나는 위에 두고 하나는 밑에 두면 됩니다. (9,6)을 위에 두고 y좌표가 작은 (8,1)은 왼쪽에 두면 됩니다.

### 시간 복잡도와 전체 코드

그럼 k-d tree를 만드는 데 걸리는 시간복잡도는 어떻게 될까요? 각 노드에서 중앙값을 구하는 데에는 그 노드의 서브트리에 속한 점들의 수를 N이라 할 때 O(NlogN)의 시간이 걸립니다. 한 높이에 N개의 점이 존재하고 높이는 최대 O(logN)이므로 한 높이에서 O(NlogN)*최대 높이 O(logN)을 곱하면 O(Nlog^2N)입니다.

k-d트리를 구현한 코드입니다. 세그먼트 트리나 힙에서도 쓰이는 아이디어를 이용해서 루트 노드의 번호를 1로 하고, 한 노드의 번호를 k라 했을 때 2*k가 왼쪽 자식의 번호, 2*k+1이 오른쪽 자식의 번호가 되도록 하였습니다.([링크](https://ideone.com/pih6Ug))

### 활용

그러면 이제 k-d tree를 어떻게 활용하죠? 사실 ps에서 활용하는 방법이 많지는 않습니다.

하지만 CERC 2008에서 딱 이것을 이용할 수 있는 문제가 나왔습니다! ([링크]( https://www.acmicpc.net/problem/7890 ))<br>무려 루비네요... 역시 이상한 자료구조에요.

여러 개의 점들이 주어질 때, 각각의 점에서 가장 가까운 점을 찾을 때 쓸 수 있습니다!<br>트리를 재귀적으로 내려가면서 그 점이 있는 방향으로는 무조건 내려가고, 그 점이 없는 방향에는 그 점과의 x(y좌표)의 최소 차이가 현재 최솟값보다 작다면 내려가주면 됩니다.

코드는 이렇게 됩니다. ([링크](https://ideone.com/PM2a63))<br>주석에 설명이 잘 달려있으니 이해 가능할 겁니다.
